name: codex-review-gate

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - edited
      - ready_for_review
  pull_request_review:
    types:
      - submitted
      - edited
      - dismissed
  pull_request_review_comment:
    types:
      - created
      - edited
      - deleted
  issue_comment:
    types:
      - created
      - edited
      - deleted

permissions:
  contents: read
  issues: read
  pull-requests: read

jobs:
  codex-review-gate:
    if: ${{ github.event_name != 'issue_comment' || github.event.issue.pull_request != null }}
    runs-on: ubuntu-latest
    steps:
      - name: Validate codex review and comment resolution
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request?.number ?? context.payload.issue?.number;

            if (!prNumber) {
              core.setFailed('No pull request number found in event payload.');
              return;
            }

            const parseDate = (value) => {
              const parsed = new Date(value ?? 0);
              return Number.isNaN(parsed.getTime()) ? new Date(0) : parsed;
            };

            const isAtOrAfter = (value, threshold) => parseDate(value).getTime() >= threshold.getTime();

            const isCodexReviewer = (login) => {
              if (!login) return false;
              const normalized = login.toLowerCase();
              return normalized === 'chatgpt-codex-connector' ||
                normalized === 'chatgpt-codex-connector[bot]';
            };

            const isCodexReviewRequest = (body) => /(^|\s)@codex\s+review(\b|$)/i.test(body ?? '');

            const pull = (await github.rest.pulls.get({ owner, repo, pull_number: prNumber })).data;
            const prAuthor = pull.user?.login;
            const headSha = pull.head?.sha;

            if (!prAuthor || !headSha) {
              core.setFailed('Unable to determine PR author or head SHA.');
              return;
            }

            const headCommit = await github.rest.repos.getCommit({ owner, repo, ref: headSha });
            const headTimestamp = parseDate(
              headCommit.data.commit.committer?.date ??
              headCommit.data.commit.author?.date
            );

            const issueComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const reviewRequests = issueComments.filter((comment) => {
              return comment.user?.login === prAuthor && isCodexReviewRequest(comment.body);
            });

            if (reviewRequests.length === 0) {
              core.setFailed(`Missing "@codex review" comment from PR author (${prAuthor}).`);
              return;
            }

            const latestReviewRequest = [...reviewRequests].sort((a, b) => {
              return parseDate(a.created_at) - parseDate(b.created_at);
            })[reviewRequests.length - 1];

            const latestReviewRequestAt = parseDate(latestReviewRequest.created_at);

            if (latestReviewRequestAt.getTime() < headTimestamp.getTime()) {
              core.setFailed(
                `Latest "@codex review" request predates HEAD (${headSha.slice(0, 7)}). ` +
                'Add a fresh "@codex review" comment after your latest push.'
              );
              return;
            }

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const codexReviews = reviews.filter((review) => {
              if (!isCodexReviewer(review.user?.login)) return false;
              return review.state && review.state !== 'PENDING' && review.state !== 'DISMISSED';
            });

            const relevantCodexReviews = codexReviews.filter((review) => {
              return isAtOrAfter(review.submitted_at, latestReviewRequestAt) &&
                isAtOrAfter(review.submitted_at, headTimestamp);
            });

            const codexIssueResponses = issueComments.filter((comment) => {
              if (!isCodexReviewer(comment.user?.login)) return false;
              return isAtOrAfter(comment.created_at, latestReviewRequestAt) &&
                isAtOrAfter(comment.created_at, headTimestamp);
            });

            if (relevantCodexReviews.length === 0 && codexIssueResponses.length === 0) {
              core.setFailed('Missing codex response after latest "@codex review" request.');
              return;
            }

            if (relevantCodexReviews.length > 0) {
              const latestCodexReview = [...relevantCodexReviews].sort((a, b) => {
                return parseDate(a.submitted_at) - parseDate(b.submitted_at);
              })[relevantCodexReviews.length - 1];

              if (latestCodexReview.state === 'CHANGES_REQUESTED') {
                core.setFailed('Latest codex review after request is CHANGES_REQUESTED.');
                return;
              }
            }

            const unresolvedThreads = [];
            let cursor = null;

            while (true) {
              const query = `
                query($owner: String!, $repo: String!, $number: Int!, $cursor: String) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $number) {
                      reviewThreads(first: 100, after: $cursor) {
                        nodes {
                          id
                          isResolved
                          comments(first: 100) {
                            nodes {
                              author {
                                login
                              }
                              url
                            }
                          }
                        }
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                      }
                    }
                  }
                }
              `;

              const result = await github.graphql(query, {
                owner,
                repo,
                number: prNumber,
                cursor,
              });

              const reviewThreads = result.repository.pullRequest.reviewThreads;
              for (const thread of reviewThreads.nodes) {
                if (thread.isResolved) continue;
                const codexComment = thread.comments.nodes.find((comment) => isCodexReviewer(comment.author?.login));
                if (codexComment) {
                  unresolvedThreads.push(codexComment.url || thread.id);
                }
              }

              if (!reviewThreads.pageInfo.hasNextPage) break;
              cursor = reviewThreads.pageInfo.endCursor;
            }

            if (unresolvedThreads.length > 0) {
              core.setFailed(`Found ${unresolvedThreads.length} unresolved review thread(s) from codex.`);
              return;
            }

            core.notice(`Codex review gate passed for PR #${prNumber}.`);
